#### 상태 

6장에서는 상태 사용과 관련된 Pattern 을 알아본다.

객체는 상태와 상태를 이용한 행위들로 구성된다. 

> 연관된 상태를 각 객체에 선언하고 그와 관련된 행위(`method`)를 정의한다.

상태를 잘게 쪼개서 객체로 관리하면 특정 변화에 의해 상태가 어떤 영향을 받을지 분석하기 훨씬 수월해진다.


```aidl
상태 : 공용 상태 / 가변 상태 / 외재 상태 
접근 : 직접 접근 / 간접 접근 
변수 

초기화  : 열성적 초기화 / 게으른 초기화  
파라미터 : 수집 파라미터 / 파라미터 객체 
```  


#### 상태 

> 상태는 행위의 총 집합체 (feat. 객체지향의 사실과 오해)

상태를 사용하면 위험요소가 유입되는건 감수해야한다.  
잘못된 상태를 가정해서 프로그램을 짤 수도 있고, 예상치 않게 상태가 변해버릴 수 있다.
-

FP에서는 변화하는 상태의 개념이 없다. 하지만, 우리 두뇌 자체가 변화하는 상태에 적합하게 대응하도록 되어있기 때문에, 함수형 언어는 대중적인 인기를 얻지 못했다(?).

객체지향언어는 상태를 다루는데 적합한 전략인다.
전체 시스템을 매우 작은 단위로 쪼갠 후 엄격한 접근 권한을 사용해서 알지 못하는 사이에 상태가 변해버리는 문제를 막아준다. 

> 외부에서 내부 상태에 접근하지 못하도록 막아(private) 알지 못하는 사이에 상태가 변하지 않도록 한다는 의미인듯.

효과적으로 상태를 관리하기 위해 유사한 상태를 묶어서 관리하고 각 상태를 별도로 관리해야한다.
`유사한 상태`의 단서로는 두 개의 상태가 동일한 연산에서 사용되는가 ? , 동일한 시점에 생성되고 소멸되는가 를 보면 된다.

#### 공용 상태 

프로그램을 짜다보면 여러 연산에서 같은 데이터 요소를 사용하는 경우가 많다.
이런 경우 클래스에 필드를 선언해서 사용하는 것이 좋다.

> ex RabbitPageView (Viewer obj 지만 ..)

유사한 방식으로 `파라미터 객체`가 있다.

`limit, offset , count` 등 여러 함수에서 동일한 형태의 parameter 가 사용되면 객체화 시켜서 전달 시킬 수 있다.

> parameter 가 5개 이상일 때 사용하기 좋을 것 같다. 성능의 이야기를 하지만, 개인적으론 가독성이 더 좋다면 사용하는 편이다. 


#### 가변상태 

가변상태는 데이터 요소의 이름을 키로하고 값을 데이터로 하는 맵으로 표현된다.

```aidl
Map<String, String> map = new HashMap();
map.put("key1", "value1");
map.put("key2", "value2");
...
```

공용 상태와는 다르게, 유연하지만 코드 커뮤네케이션이 쉽지 않다.
내부 값들을 확인하기 위해서는 코드를 주의 깊게 읽어야하고 때로는 수행 과정을 지켜봐야한다.

각 필드에 상태에 따라 다른 필드를 필요로하는 경우, 가변 상태의 사용을 정당화 할 수 있다. 

예를 들어 아래와같은 데이터가 있다고 가정하자. 

```androiddatabinding
bordered true 
borderWidth 5
borderColor red 
```

위 상황에서 bordered 라는 값이 `false` 일 경우, width / color 들은 빈 값이 들어가게 된다.
만약 공용상태를 사용하게 되면, 객체 내부의 변수들의 생명주기가 같아야한다는 원칙을 어기게 된다.

공유 상태 / 가변 상태는 경우에 따라 판단해야하고 가능하다면 공유 상태를 사용하도록 해라.

> 특별한 케이스가 아니면, 공유 상태로 명확성(?)을 높여야한다고 생각한다.

위와 유사한 방식으로 `가변 인자`가 있다.
주로 `RestTemplate` / `MyBatis` 등에 parameter 를 넘겨줄때 사용된다.
또한 가변 인자는 항상 마지막 파라미터여야한다.

> varargs 도 이러한 용도로 사용된다고 한다.

#### 외재 상태 

어떤 객체와 관련된 특수 목적 정보는 객체가 아니라 그 객체를 필요로 하는 부분에 저장하는 편이 났다.

> 개인적으로 이해한건, FileUtil.java / UploadPolicy.java 사이의 관계라고 이해함. 
 

#### 직접 접근 

데이터를 가져오는 가장 간단한 방법은 변수에 직접 접근하는 것이다.

```aidl
 x = 1; 

 or
 
 obj.x = 1; 
```

직접 접근의 장점은 명확성이다. 해당 변수가 어떻게 바뀌는지 한눈에 알 수있다.
다만, 직접 접근의 단점은 프로그래머가 사고하는 수준보다 낮은 수준에서 세부구현을 사용한다는 점이다. 
`x=1` 요 코드만으로는 1이 어떤걸 의미하는지 알 수 없다.  (이름을 지을 수있다.)

또한 `유연성`의 관점으로 봤을 때 직접 접근은 좋은 방법이 아니다.
여러 부분에서 위 코드가 사용된다면, 요구 사항이 바뀌었을 때 변경되는 부분이 많다.

> 위 같은 이유로 극단적(?)인 상황에서는 객체 내부에서도 setter / getter 를 이용해 변수를 가져온다. (feat. refactoring)

어떤 사람들은 접근자 메서드나 생성자 내부에서만 직접 접근을 허락해야한다고 하고, 또 다른 사람들은 단일 클래스 내부, 하위클래스 내부, 패키지 내부 까지 직접 접근을 허락해야한다고 주장한다.
하지만 모든 경우에 적용할 만한 규칙은 없다. 프로그래머는 생각하고 커뮤니케이션하고 배워야한다. 
그것이 전문 프로그래머의 자세다 .. 

#### 간접 접근 

접근자 메서드를 사용하면 명확성과 직접성을 희생해서 유연성을 얻을 수 있다.

> 여기서 말하는 명확성은 내부 로직이 어떻게 돌아가느냐를 뜻함.

`1.` 내부 클래스에선 직접 접근을 사용하고 외부에선 간접 접근을 사용하는 방법.
`2.` 내부 / 외부에서 모두 간접 접근을 사용하는 방법 

```aidl
void setWidth(int width){
    this.width = width;
    area = width * width;
}
```


#### 변수 

`1.` 변수 이름을 통해 많은 정보를 전달하려는 시도가 있었지만, 가급적이면 단순한 이름을 통해 코드를 단순화 하는편이 좋다.
`2.` 변수의 생명기간은 변수의 범위보다 작을 수 있다. 어떤 메소드가 활성화 됐을때만 필드를 유효화 할 수도 있지만 이런코드는 좋지 않다.
변수의 생명 기간은 가급적이면 변수의 범위에 가까워지도록 노력하라

> item 59. 지역변수의 범위를 최소화 하라.

#### 선언 타입 

자바와 같이 타입을 강제하는 언어에서는 변수의 타입을 선언해야한다. 
타입 선언을 피할 수 없다면, 이를 커뮤니케이션에 이용하는 것도 좋을 것이다.

```androiddatabinding
List list; 

...

list = new ArrayList();
```

> 위처럼 사용하지말고, 선언과 동시에 초기화를 하는것이 좋다. 

때로 메서드 파라미터에 collection 으로 받는 경우가 있는데, 선언의 불일치 보단 일관성을 위해 `Collection`으로 선언하는 것도 괜찮다.

#### 초기화 

초기화는 변수가 사용되기 전에 알고있는 상태로 만드는 작업이다.

가급적 초기화는 선언과 함께 사용하는게 좋다. 

> (다시..) item 59. 지역변수의 범위를 최소화 하라.

#### 열성적 초기화

열성적 초기화는 변수가 생성되자마자 초기화한다. 
열성적 초기화의 경우 모든 변수가 초기화 이후에 사용되는 것을 보장 할 수 있다. 

> Autowired : 생성자 주입 / setter 주입  

#### 게으른 초기화 

대부분의 경우 열성적 초기화를 사용하면 되지만, 초기화 비용이 상당하고 비용 부담을 가급적 늦추고 싶다면 게으른 초기화를 사용하면 된다.

```androiddatabinding
void getMembers(){
    if(this.members == null ){
        this.members = new ArrayList();
    }
    return members;
}
```

다만 게으른 초기화는 가독성을 현저히 떨어뜨릴 수 있다. 꼭 필요한 상황이 아니라면 사용을 피하는 것이 좋다.

> item 83. 지연 초기화는 신중히 사용하라

#### 파라미터 

필드 혹은 정적 필드를 사용하면 의존성이 늘어나므로, 가능하면 파라미터를 사용하도록 해야한다.


#### 수집 파라미터 

말 그대로 parameter 에 collection 을 주입하여 값을 `수집` 하는 용도이다.

```androiddatabinding
// 요런 느낌 
addTo(List list){
    for(int some : somethings){
        list.add(some);
    }
}
```

#### 옵션 파라미터 

> java 에서는 default parameter 값을 할당할 수 없는데, overloading 으로 유사하게 동작 시킬 수 있다.

```androiddatabinding
public ServerSocket();
public ServerSocket(int port);
public ServerSocket(int port, int backlog);
```




