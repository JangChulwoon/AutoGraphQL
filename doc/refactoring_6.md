#### 메서드 정리

리팩토링의 주된 작업은 메서드를 적절히 정리하는 것이다.
대부분의 문제는 장황한 메서드로 인해 발생하며, 이 번 장에서는 장황한 메서드들을 정리하는 방법들에 대해 다룬다.

> 총 9가지의 방법이 서술되어 있다.

```
1. 메서드 추출
2. 메서드 내용 직접 삽입
3. 임시변수 내용 직접 삽입
4. 임시 변수를 메서드 호출로 전환
5. 직관적 임시변수 사용
6. 임시변수 분리
7. 매개변수로의 값 대입 제거
8. 메서드를 메서드 객체로 전환
9. 알고리즘 전환
```

#### 1. 메서드 추출

메서드 추출 방식은, 말그대로 길고 장황한 메서드를 분리하는 작업을 말한다.

```
1. 메서드가 길때
2. 기능이나 목적을 주석으로 설명해야할 때
```

위 2가지 상황에 처한 메서드일 경우, 메서드 분리를 고려해봐야한다.

> 다만 적절하지 않은 메서드 이름으로 추출할 바엔, 분리하지 말아야한다.

```
1. 목적(기능)에 걸맞는 메서드 이름을 짓는다.
2. 기존 메서드가 분리된 메서드를 바라보도록 한다.
3. 연관된 지역변수를 찾고, 추출된 메서드에서만 사용된다면 이동시킨다.
4. 컴파일 및 테스트를 진행한다.
```

> 주의 : 리펙토링에서 가장 중요한 요소 중 하나는 TC 이다.  

TC가 존재하지 않는다면, 리팩토링을 진행해선 안된다.   
만약 TC가 없다면 리팩토링을 하기 전 TC를 생성해두고 리팩토링을 진행해야한다.

> 어디까지 검증을 할 것인가도 중요한 문제

#### 예제 1.

```
void printOwing(List<Order> orderList) {

    def totalPrice = 0

    println("---- ---- ---- -----")
    println("---- order List ----")
    println("---- ---- ---- -----")

    for (Order order : orderList) {
        totalPrice += order.price
    }

    println("---- ---- ---- -----")
    println("TOTAL PRICE : ${totalPrice}")
    println("---- ---- ---- -----")
}
```

위 코드는 단순 문자열을 print 하는 부분과 총 가격을 계산하는 부분, 그 결과를 출력하는 부분 총 3가지로 나눌 수 있다.
작업을 수행하기전, TC를 만들어 두고 리팩토링을 수행하자.

#### Phase 1 print 함수 분리 


```
void printOwing(List<Order> orderList) {

    def totalPrice = 0

    printTopMenu()
    
    for (Order order : orderList) {
        totalPrice += order.price
    }

    println("---- ---- ---- -----")
    println("TOTAL PRICE : ${totalPrice}")
    println("---- ---- ---- -----")
}

void printTopMenu(){
    println("---- ---- ---- -----")
    println("---- order List ----")
    println("---- ---- ---- -----")
}

```

위와 같이 함수를 쪼개면서 refactoring 을 진행한다.

> Live Coding .... ?

> 여기서 3. 임시변수 내용 직접 삽입도 함께 설명합니다.


#### TC에 관한 개인적인 고민들 

> 단순 void 일 경우 TC를 어떻게 작성하지? 단순 call 을 확인하면 되나 ?

사실 refactoring 에서 말하는 TC는 blackBox 의 느낌.

> 다들 TC는 어떻게 짜시나요 ? 

#### 2. 메서드 내용 직접 삽입

메서드 추출과는 반대의 내용으로 분리된 함수를 다시 끌어오는 기법.

> 이전 예제를 갖고 다시 Live .. 


#### 4. 임시 변수를 메서드 호출로 전환

이전 주에 말씀하신것 처럼, 책의 저자는 임시 변수를 극도로 싫어한다.

지역변수가 많아질 경우, 다루기가 어려움으로 메서드 추출을 하기전, `Replace Temp with Query` 기법을 먼저 실행한다.

```
1. final 로 임시변수를 선언
만약 재할당이 일어나면 이 기법은 사용할 수 없다.
2. 컴파일
3. 함수로 변경
4. 대입 
```

이렇게하면 callStack은 늘어날 수 있으나, Class의 다른 메서드에서도 접근할 수 있으므로, 가치가 올라간다.

> Live 

#### 5. 직관적인 임시변수 사용 

조건문이나, 장황한 조건문에 대해서, 임시변수를 사용해서 이름을 붙인다.

> 다만 책의 저자는 임시변수 보단, 함수로 빼는걸 좋아한다.

다른 메서드에서도 접근할 수 있기때문에 더욱더 좋아하는 듯.
(임시변수를 혐오(?)하는 성향도 ...)


#### 6. 임시변수  분리 

임시변수 하나가 2가지 이상의 용도로 사용될 경우, 분리해라

```

double temp = 2 * (height + width)
sout(temp)
temp = height * width
sout(temp)

```

위 코드에서 temp는 2번 할당된다.
이는 한가지 변수에 너무 많은 역할이 부여된것으로, 
여러 용도로 사용되는 변수는 각 용도 별로 다른 변수를 사용하도록 분리되어야한다.


#### 7. 매개변수로의 값 대입 제거

넘어온 파라미터를 재할당하는 짓은 하지말것.

> 객체는 pass by value 지만, 레퍼런스의 값을 넘기기에 영향을 줄 수 있음

조금 극단적인 사람들은 final 로 도배하기도 한다.

#### 8. 메서드를 메서드 객체로 전환


함수의 인자 또는 자역변수들이 많을때  객체로 묶는 작업
유사한 목적으로 생성된 지역변수들을 class로 분리하고 그걸 사용한다. 


#### 9. 알고리즘 전환

내부 알고리즘을 바꿀땐, 전환 후 모든 TC가 성공해야한다.


6장 메서드 정리 끝.

