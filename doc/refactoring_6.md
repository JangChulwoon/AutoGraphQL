#### 메서드 정리

리팩토링의 주된 작업은 메서드를 적절히 정리하는 것이다.
대부분의 문제는 장황한 메서드로 인해 발생하며, 이 번 장에서는 장황한 메서드들을 정리하는 방법들에 대해 다룬다.

> 총 9가지의 방법이 서술되어 있다.

```
1. 메서드 추출
2. 메서드 내용 직접 삽입
3. 임시변수 내용 직접 삽입
4. 임시 변수를 메서드 호출로 전환
5. 직관적 임시변수 사용
6. 임시변수 분리
7. 매개변수로의 값 대입 제거
8. 메서드를 메서드 객체로 전환
9. 알고리즘 전환
```

이 중, `1,2,4,8` 에 대해서 정리한다.

> 그 외 방법들은 비교적 간단한 내용이기에 별도의 설명을 하지 않는다.

#### 1. 메서드 추출

메서드 추출 방식은, 말그대로 길고 장황한 메서드를 분리하는 작업을 말한다.

```
1. 메서드가 길때
2. 기능이나 목적을 주석으로 설명해야할 때
```

위 2가지 상황에 처한 메서드일 경우, 메서드 분리를 고려해봐야한다.

> 다만 적절하지 않은 메서드 이름으로 추출할 바엔, 분리하지 말아야한다.

```
1. 목적(기능)에 걸맞는 메서드 이름을 짓는다.
2. 기존 메서드가 분리된 메서드를 바라보도록 한다.
3. 연관된 지역변수를 찾고, 추출된 메서드에서만 사용된다면 이동시킨다.
4. 컴파일 및 테스트를 진행한다.
```

> 주의 : 리펙토링에서 가장 중요한 요소 중 하나는 TC 이다.  

TC가 존재하지 않는다면, 리팩토링을 진행해선 안된다.   
만약 TC가 없다면 리팩토링을 하기 전 TC를 생성해두고 리팩토링을 진행해야한다.

> 어디까지 검증을 할 것인가도 중요한 문제

#### 예제 1.

```
void printOwing(List<Order> orderList) {

    def totalPrice = 0

    println("---- ---- ---- -----")
    println("---- order List ----")
    println("---- ---- ---- -----")

    for (Order order : orderList) {
        totalPrice += order.price
    }

    println("---- ---- ---- -----")
    println("TOTAL PRICE : ${totalPrice}")
    println("---- ---- ---- -----")
}
```

위 코드는 단순 문자열을 print 하는 부분과 총 가격을 계산하는 부분, 그 결과를 출력하는 부분 총 3가지로 나눌 수 있다.
작업을 수행하기전, TC를 만들어 두고 리팩토링을 수행하자.

> 단순 void 일 경우 TC를 어떻게 작성하지? 단순 call 을 확인하면 되나 ?

단순 call 정도만 확인하면 되지 않을까 싶다. 
너무 깊게 관여할 필요 없이 call의 순서와 예상되는 결과에 대해, 함수가 어떤 결과를 리턴하는지 정도만 확인하면 되지 않을까 ?

(최근 내가 작성한 TC 를 보여줘도 좋을 듯.)


#### 2. 메서드 내용 직접 삽입

메서드 추출과는 반대의 내용으로 분리된 함수를 다시 끌어오는 기법.


#### 4. 임시 변수를 메서드 호출로 전환

임시변수를 삭제.


#### 8. 메서드를 메서드 객체로 전환


함수의 인자가 많거나, 중복되었을 때 객체로 묶는 작업
